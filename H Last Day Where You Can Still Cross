class Solution {
public:
    int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
        int left = 1, right = cells.size();
        while (left < right) {
            int mid = right - (right - left) / 2;
            if (canCross(row, col, cells, mid)) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

    bool canCross(int row, int col, vector<vector<int>>& cells, int day) {
        vector<vector<int>> grid(row, vector<int>(col, 0));
        for (int i = 0; i < day; ++i) {
            int r = cells[i][0] - 1, c = cells[i][1] - 1;
            grid[r][c] = 1;
        }
        for (int j = 0; j < col; ++j) {
            if (grid[0][j] == 0 && dfs(0, j, grid)) {
                return true;
            }
        }
        return false;
    }

    bool dfs(int x, int y, vector<vector<int>>& grid) {
        int row = grid.size(), col = grid[0].size();
        if (x == row - 1)
            return true;
        grid[x][y] = 1;
        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
        for (auto& dir : dirs) {
            int nx = x + dir.first, ny = y + dir.second;
            if (nx >= 0 && ny >= 0 && nx < row && ny < col &&
                grid[nx][ny] == 0) {
                if (dfs(nx, ny, grid))
                    return true;
            }
        }
        return false;
    }
};
